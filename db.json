[{"model": "contenttypes.contenttype", "pk": 1, "fields": {"app_label": "admin", "model": "logentry"}}, {"model": "contenttypes.contenttype", "pk": 2, "fields": {"app_label": "auth", "model": "permission"}}, {"model": "contenttypes.contenttype", "pk": 3, "fields": {"app_label": "auth", "model": "group"}}, {"model": "contenttypes.contenttype", "pk": 4, "fields": {"app_label": "auth", "model": "user"}}, {"model": "contenttypes.contenttype", "pk": 5, "fields": {"app_label": "contenttypes", "model": "contenttype"}}, {"model": "contenttypes.contenttype", "pk": 6, "fields": {"app_label": "sessions", "model": "session"}}, {"model": "contenttypes.contenttype", "pk": 7, "fields": {"app_label": "wiki", "model": "page"}}, {"model": "sessions.session", "pk": "6ic0muj9ljboxwc6gn023861in8x77s2", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2019-12-16T23:02:41.430Z"}}, {"model": "sessions.session", "pk": "80vf2vpuzqctslggb7dxwyvcea0mch94", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2019-11-27T21:37:40.230Z"}}, {"model": "sessions.session", "pk": "8uklrtpelj3scjn8p9oz64ugkb95mdfs", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2019-12-04T23:12:06.897Z"}}, {"model": "sessions.session", "pk": "d9j18fpl12eive0s2m2tol8eqeqjdz36", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T07:59:39.025Z"}}, {"model": "sessions.session", "pk": "eba6xgxgsdxbn5lywmygvmo92stkf3vv", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T09:14:52.408Z"}}, {"model": "sessions.session", "pk": "m2nyi14z2r2mmijbymoou9ekraiklr25", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T09:18:05.779Z"}}, {"model": "sessions.session", "pk": "tt57bgs67rfm3en3r64ra59z4ibmwdt6", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T09:53:35.074Z"}}, {"model": "sessions.session", "pk": "vj7k37ufyfwah4yhn6utug8rdx8veu51", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2019-11-18T21:16:37.648Z"}}, {"model": "sessions.session", "pk": "xua968p8uvb7btflxuln858j57tcbyux", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T08:19:18.978Z"}}, {"model": "sessions.session", "pk": "xw1wk2jzsqb0tblxtw5e98yu1yrdj6nz", "fields": {"session_data": "ZTQyYjE1MTRlYzYyYTM1MTg4NWM2Y2JhOWY4MGU4MjE4ZmUwM2FlYzp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJmZjI4MmMzMjE3ZWVlMWFmYTMxZjRjYTZiY2ZhZmI4OTUwZmU5MDM1In0=", "expire_date": "2020-01-12T05:48:15.819Z"}}, {"model": "auth.permission", "pk": 1, "fields": {"name": "Can add log entry", "content_type": 1, "codename": "add_logentry"}}, {"model": "auth.permission", "pk": 2, "fields": {"name": "Can change log entry", "content_type": 1, "codename": "change_logentry"}}, {"model": "auth.permission", "pk": 3, "fields": {"name": "Can delete log entry", "content_type": 1, "codename": "delete_logentry"}}, {"model": "auth.permission", "pk": 4, "fields": {"name": "Can view log entry", "content_type": 1, "codename": "view_logentry"}}, {"model": "auth.permission", "pk": 5, "fields": {"name": "Can add permission", "content_type": 2, "codename": "add_permission"}}, {"model": "auth.permission", "pk": 6, "fields": {"name": "Can change permission", "content_type": 2, "codename": "change_permission"}}, {"model": "auth.permission", "pk": 7, "fields": {"name": "Can delete permission", "content_type": 2, "codename": "delete_permission"}}, {"model": "auth.permission", "pk": 8, "fields": {"name": "Can view permission", "content_type": 2, "codename": "view_permission"}}, {"model": "auth.permission", "pk": 9, "fields": {"name": "Can add group", "content_type": 3, "codename": "add_group"}}, {"model": "auth.permission", "pk": 10, "fields": {"name": "Can change group", "content_type": 3, "codename": "change_group"}}, {"model": "auth.permission", "pk": 11, "fields": {"name": "Can delete group", "content_type": 3, "codename": "delete_group"}}, {"model": "auth.permission", "pk": 12, "fields": {"name": "Can view group", "content_type": 3, "codename": "view_group"}}, {"model": "auth.permission", "pk": 13, "fields": {"name": "Can add user", "content_type": 4, "codename": "add_user"}}, {"model": "auth.permission", "pk": 14, "fields": {"name": "Can change user", "content_type": 4, "codename": "change_user"}}, {"model": "auth.permission", "pk": 15, "fields": {"name": "Can delete user", "content_type": 4, "codename": "delete_user"}}, {"model": "auth.permission", "pk": 16, "fields": {"name": "Can view user", "content_type": 4, "codename": "view_user"}}, {"model": "auth.permission", "pk": 17, "fields": {"name": "Can add content type", "content_type": 5, "codename": "add_contenttype"}}, {"model": "auth.permission", "pk": 18, "fields": {"name": "Can change content type", "content_type": 5, "codename": "change_contenttype"}}, {"model": "auth.permission", "pk": 19, "fields": {"name": "Can delete content type", "content_type": 5, "codename": "delete_contenttype"}}, {"model": "auth.permission", "pk": 20, "fields": {"name": "Can view content type", "content_type": 5, "codename": "view_contenttype"}}, {"model": "auth.permission", "pk": 21, "fields": {"name": "Can add session", "content_type": 6, "codename": "add_session"}}, {"model": "auth.permission", "pk": 22, "fields": {"name": "Can change session", "content_type": 6, "codename": "change_session"}}, {"model": "auth.permission", "pk": 23, "fields": {"name": "Can delete session", "content_type": 6, "codename": "delete_session"}}, {"model": "auth.permission", "pk": 24, "fields": {"name": "Can view session", "content_type": 6, "codename": "view_session"}}, {"model": "auth.permission", "pk": 25, "fields": {"name": "Can add page", "content_type": 7, "codename": "add_page"}}, {"model": "auth.permission", "pk": 26, "fields": {"name": "Can change page", "content_type": 7, "codename": "change_page"}}, {"model": "auth.permission", "pk": 27, "fields": {"name": "Can delete page", "content_type": 7, "codename": "delete_page"}}, {"model": "auth.permission", "pk": 28, "fields": {"name": "Can view page", "content_type": 7, "codename": "view_page"}}, {"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$150000$BOxQw6AxMKtD$WPbzHenydblXwAn5BDqt3pQof3kvl31hdn2kZu1s56U=", "last_login": "2019-12-29T09:53:35.070Z", "is_superuser": true, "username": "admin", "first_name": "", "last_name": "", "email": "dani@makeschool.com", "is_staff": true, "is_active": true, "date_joined": "2019-11-04T18:48:31.304Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 2, "fields": {"password": "pbkdf2_sha256$150000$gIWDlJpkl2SH$omTDpvLpJH2f8cMdwysNvPfgem35R9M6u+c6lNQ8rcY=", "last_login": null, "is_superuser": true, "username": "dani", "first_name": "Dani", "last_name": "Roxberry", "email": "dani@makeschool.com", "is_staff": true, "is_active": true, "date_joined": "2019-11-05T22:34:33Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 3, "fields": {"password": "pbkdf2_sha256$150000$nEMfHAbIMPYR$Q6cFBpRZu9tIfWnkZHUqsFZJlyssG7eRFVB6rxOFu2k=", "last_login": "2019-11-11T12:32:19.328Z", "is_superuser": false, "username": "dani2", "first_name": "", "last_name": "", "email": "", "is_staff": false, "is_active": true, "date_joined": "2019-11-11T11:26:10.486Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 4, "fields": {"password": "pbkdf2_sha256$150000$1AFzUD8tslfB$Gv1pQYVz9kzG9z/hSRvoU/tieR7Mn0LuOGOytqYbsU0=", "last_login": "2019-11-11T12:10:23.477Z", "is_superuser": false, "username": "dani3", "first_name": "", "last_name": "", "email": "", "is_staff": false, "is_active": true, "date_joined": "2019-11-11T12:10:06.638Z", "groups": [], "user_permissions": []}}, {"model": "wiki.page", "pk": 4, "fields": {"slug": "computer-science", "created": "2019-11-06T01:43:08.399Z", "modified": "2019-12-29T10:47:18.290Z", "title": "Computer Science", "author": 1, "content": "The earliest foundations of what would become computer science predate the invention of the modern digital computer. Machines for calculating fixed numerical tasks such as the abacus have existed since antiquity, aiding in computations such as multiplication and division. Algorithms for performing computations have existed since antiquity, even before the development of sophisticated computing equipment.\r\n\r\nWilhelm Schickard designed and constructed the first working mechanical calculator in 1623.[4] In 1673, Gottfried Leibniz demonstrated a digital mechanical calculator, called the Stepped Reckoner.[5] He may be considered the first computer scientist and information theorist, for, among other reasons, documenting the binary number system. In 1820, Thomas de Colmar launched the mechanical calculator industry[note 1] when he released his simplified arithmometer, which was the first calculating machine strong enough and reliable enough to be used daily in an office environment. Charles Babbage started the design of the first automatic mechanical calculator, his Difference Engine, in 1822, which eventually gave him the idea of the first programmable mechanical calculator, his Analytical Engine.[6] He started developing this machine in 1834, and \"in less than two years, he had sketched out many of the salient features of the modern computer\".[7] \"A crucial step was the adoption of a punched card system derived from the Jacquard loom\"[7] making it infinitely programmable.[note 2] In 1843, during the translation of a French article on the Analytical Engine, Ada Lovelace wrote, in one of the many notes she included, an algorithm to compute the Bernoulli numbers, which is considered to be the first published algorithm ever specifically tailored for implementation on a computer.[8] Around 1885, Herman Hollerith invented the tabulator, which used punched cards to process statistical information; eventually his company became part of IBM. Following Babbage, although unaware of his earlier work, Percy Ludgate in 1909 published [9] the 2nd of the only two designs for mechanical analytical engines in history. In 1937, one hundred years after Babbage's impossible dream, Howard Aiken convinced IBM, which was making all kinds of punched card equipment and was also in the calculator business[10] to develop his giant programmable calculator, the ASCC/Harvard Mark I, based on Babbage's Analytical Engine, which itself used cards and a central computing unit. When the machine was finished, some hailed it as \"Babbage's dream come true\".[11]\r\n\r\nDuring the 1940s, as new and more powerful computing machines such as the Atanasoff\u2013Berry computer and ENIAC were developed, the term computer came to refer to the machines rather than their human predecessors.[12] As it became clear that computers could be used for more than just mathematical calculations, the field of computer science broadened to study computation in general. In 1945, IBM founded the Watson Scientific Computing Laboratory at Columbia University in New York City. The renovated fraternity house on Manhattan's West Side was IBM's first laboratory devoted to pure science. The lab is the forerunner of IBM's Research Division, which today operates research facilities around the world.[13] Ultimately, the close relationship between IBM and the university was instrumental in the emergence of a new scientific discipline, with Columbia offering one of the first academic-credit courses in computer science in 1946.[14] Computer science began to be established as a distinct academic discipline in the 1950s and early 1960s.[15][16] The world's first computer science degree program, the Cambridge Diploma in Computer Science, began at the University of Cambridge Computer Laboratory in 1953. The first computer science department in the United States was formed at Purdue University in 1962.[17] Since practical computers became available, many applications of computing have become distinct areas of study in their own rights.\r\n\r\nAlthough many initially believed it was impossible that computers themselves could actually be a scientific field of study, in the late fifties it gradually became accepted among the greater academic population.[18][19] It is the now well-known IBM brand that formed part of the computer science revolution during this time. IBM (short for International Business Machines) released the IBM 704[20] and later the IBM 709[21] computers, which were widely used during the exploration period of such devices. \"Still, working with the IBM [computer] was frustrating [\u2026] if you had misplaced as much as one letter in one instruction, the program would crash, and you would have to start the whole process over again\".[18] During the late 1950s, the computer science discipline was very much in its developmental stages, and such issues were commonplace.[19]\r\n\r\nThe concept of a field-effect transistor was proposed by Julius Edgar Lilienfeld in 1925. John Bardeen and Walter Brattain, while working under William Shockley at Bell Labs, built the first working transistor, the point-contact transistor, in 1947.[22][23] In 1953, the University of Manchester built the first transistorized computer, called the Transistor Computer.[24] However, early junction transistors were relatively bulky devices that were difficult to manufacture on a mass-production basis, which limited them to a number of specialised applications.[25] The metal\u2013oxide\u2013silicon field-effect transistor (MOSFET, or MOS transistor) was invented by Mohamed Atalla and Dawon Kahng at Bell Labs in 1959.[26][27] It was the first truly compact transistor that could be miniaturised and mass-produced for a wide range of uses.[25] The MOSFET made it possible to build high-density integrated circuit chips,[28][29] leading to what is known as the computer revolution[30] or microcomputer revolution.[31]\r\n\r\nTime has seen significant improvements in the usability and effectiveness of computing technology.[32] Modern society has seen a significant shift in the users of computer technology, from usage only by experts and professionals, to a near-ubiquitous user base. Initially, computers were quite costly, and some degree of humanitarian aid was needed for efficient use\u2014in part from professional computer operators. As computer adoption became more widespread and affordable, less human assistance was needed for common usage.\r\n\r\nSee also: History of computing and History of informatics\r\nContributions\r\n\r\nThe German military used the Enigma machine (shown here) during World War II for communications they wanted kept secret. The large-scale decryption of Enigma traffic at Bletchley Park was an important factor that contributed to Allied victory in WWII.[33]\r\nDespite its short history as a formal academic discipline, computer science has made a number of fundamental contributions to science and society\u2014in fact, along with electronics, it is a founding science of the current epoch of human history called the Information Age and a driver of the information revolution, seen as the third major leap in human technological progress after the Industrial Revolution (1750\u20131850 CE) and the Agricultural Revolution (8000\u20135000 BCE).\r\n\r\nThese contributions include:\r\n\r\nThe start of the \"Digital Revolution\", which includes the current Information Age and the Internet.[34]\r\nA formal definition of computation and computability, and proof that there are computationally unsolvable and intractable problems.[35]\r\nThe concept of a programming language, a tool for the precise expression of methodological information at various levels of abstraction.[36]\r\nIn cryptography, breaking the Enigma code was an important factor contributing to the Allied victory in World War II.[33]\r\nScientific computing enabled practical evaluation of processes and situations of great complexity, as well as experimentation entirely by software. It also enabled advanced study of the mind, and mapping of the human genome became possible with the Human Genome Project.[34] Distributed computing projects such as Folding@home explore protein folding.\r\nAlgorithmic trading has increased the efficiency and liquidity of financial markets by using artificial intelligence, machine learning, and other statistical and numerical techniques on a large scale.[37] High frequency algorithmic trading can also exacerbate volatility.[38]\r\nComputer graphics and computer-generated imagery have become ubiquitous in modern entertainment, particularly in television, cinema, advertising, animation and video games. Even films that feature no explicit CGI are usually \"filmed\" now on digital cameras, or edited or post-processed using a digital video editor.[39][40]\r\nSimulation of various processes, including computational fluid dynamics, physical, electrical, and electronic systems and circuits, as well as societies and social situations (notably war games) along with their habitats, among many others. Modern computers enable optimization of such designs as complete aircraft. Notable in electrical and electronic circuit design are SPICE,[41] as well as software for physical realization of new (or modified) designs. The latter includes essential design software for integrated circuits.[citation needed]\r\nArtificial intelligence is becoming increasingly important as it gets more efficient and complex. There are many applications of AI, some of which can be seen at home, such as robotic vacuum cleaners. It is also present in video games and on the modern battlefield in drones, anti-missile systems, and squad support robots.[42]\r\nHuman\u2013computer interaction combines novel algorithms with design strategies that enable rapid human performance, low error rates, ease in learning, and high satisfaction. Researchers use ethnographic observation and automated data collection to understand user needs, then conduct usability tests to refine designs. Key innovations include the direct manipulation, selectable web links, touchscreen designs, mobile applications, and virtual reality."}}, {"model": "wiki.page", "pk": 5, "fields": {"slug": "software-engineering-history", "created": "2019-11-06T01:45:31.621Z", "modified": "2019-11-06T01:45:31.621Z", "title": "Software Engineering History", "author": 2, "content": "When the first digital computers appeared in the early 1940s,[13] the instructions to make them operate were wired into the machine. Practitioners quickly realized that this design was not flexible and came up with the \"stored program architecture\" or von Neumann architecture. Thus the division between \"hardware\" and \"software\" began with abstraction being used to deal with the complexity of computing.\r\n\r\nProgramming languages started to appear in the early 1950s[14] and this was also another major step in abstraction. Major languages such as Fortran, ALGOL, and COBOL were released in the late 1950s to deal with scientific, algorithmic, and business problems respectively. David Parnas introduced the key concept of modularity and information hiding in 1972[15] to help programmers deal with the ever-increasing complexity of software systems.\r\n\r\nThe origins of the term \"software engineering\" have been attributed to various sources. The term \"software engineering\" appeared in a list of services offered by companies in the June 1965 issue of COMPUTERS and AUTOMATION and was used more formally in the August 1966 issue of Communications of the ACM (Volume 9, number 8) \u201cletter to the ACM membership\u201d by the ACM President Anthony A. Oettinger;,[16] it is also associated with the title of a NATO conference in 1968 by Professor Friedrich L. Bauer, the first conference on software engineering.[17] Independently, Margaret Hamilton named the discipline \"software engineering\" during the Apollo missions to give what they were doing legitimacy.[18] At the time there was perceived to be a \"software crisis\".[19][20][21] The 40th International Conference on Software Engineering (ICSE 2018) celebrates 50 years of \"Software Engineering\" with the Plenary Sessions' keynotes of Frederick Brooks[22] and Margaret Hamilton.[23]\r\n\r\nIn 1984, the Software Engineering Institute (SEI) was established as a federally funded research and development center headquartered on the campus of Carnegie Mellon University in Pittsburgh, Pennsylvania, United States. Watts Humphrey founded the SEI Software Process Program, aimed at understanding and managing the software engineering process. The Process Maturity Levels introduced would become the Capability Maturity Model Integration for Development(CMMI-DEV), which has defined how the US Government evaluates the abilities of a software development team.\r\n\r\nModern, generally accepted best-practices for software engineering have been collected by the ISO/IEC JTC 1/SC 7 subcommittee and published as the Software Engineering Body of Knowledge (SWEBOK).[24]"}}, {"model": "wiki.page", "pk": 6, "fields": {"slug": "software-testing", "created": "2019-11-06T01:46:09.033Z", "modified": "2019-11-06T01:46:09.033Z", "title": "Software Testing", "author": 2, "content": "Although software testing can determine the correctness of software under the assumption of some specific hypotheses (see the hierarchy of testing difficulty below), testing cannot identify all the defects within the software.[2] Instead, it furnishes a criticism or comparison that compares the state and behavior of the product against test oracles\u2014principles or mechanisms by which someone might recognize a problem. These oracles may include (but are not limited to) specifications, contracts,[3] comparable products, past versions of the same product, inferences about intended or expected purpose, user or customer expectations, relevant standards, applicable laws, or other criteria.\r\n\r\nA primary purpose of testing is to detect software failures so that defects may be discovered and corrected. Testing cannot establish that a product functions properly under all conditions, but only that it does not function properly under specific conditions.[4] The scope of software testing often includes the examination of code as well as the execution of that code in various environments and conditions as well as examining the aspects of code: does it do what it is supposed to do and do what it needs to do. In the current culture of software development, a testing organization may be separate from the development team. There are various roles for testing team members. Information derived from software testing may be used to correct the process by which software is developed.[5]:41\u201343\r\n\r\nEvery software product has a target audience. For example, the audience for video game software is completely different from banking software. Therefore, when an organization develops or otherwise invests in a software product, it can assess whether the software product will be acceptable to its end users, its target audience, its purchasers and other stakeholders. Software testing aids the process of attempting to make this assessment."}}, {"model": "wiki.page", "pk": 7, "fields": {"slug": "systems-engineering", "created": "2019-11-06T01:46:30.185Z", "modified": "2019-11-06T01:46:30.185Z", "title": "Systems Engineering", "author": 2, "content": "Systems engineering is an interdisciplinary field of engineering and engineering management that focuses on how to design and manage complex systems over their life cycles. At its core, systems engineering utilizes systems thinking principles to organize this body of knowledge. The individual outcome of such efforts, an engineered system, can be defined as a combination of components that work in synergy to collectively perform a useful function.\r\n\r\nIssues such as requirements engineering, reliability, logistics, coordination of different teams, testing and evaluation, maintainability and many other disciplines necessary for successful system design, development, implementation, and ultimate decommission become more difficult when dealing with large or complex projects. Systems engineering deals with work-processes, optimization methods, and risk management tools in such projects. It overlaps technical and human-centered disciplines such as industrial engineering, mechanical engineering, manufacturing engineering, control engineering, software engineering, electrical engineering, cybernetics, organizational studies, civil engineering and project management. Systems engineering ensures that all likely aspects of a project or system are considered, and integrated into a whole.\r\n\r\nThe systems engineering process is a discovery process that is quite unlike a manufacturing process. A manufacturing process is focused on repetitive activities that achieve high quality outputs with minimum cost and time. The systems engineering process must begin by discovering the real problems that need to be resolved, and identifying the most probable or highest impact failures that can occur \u2013 systems engineering involves finding solutions to these problems."}}, {"model": "wiki.page", "pk": 8, "fields": {"slug": "programming-paradigms", "created": "2019-11-06T01:46:54.578Z", "modified": "2019-11-06T01:46:54.579Z", "title": "Programming Paradigms", "author": 2, "content": "Just as software engineering (as a process) is defined by differing methodologies, so the programming languages (as models of computation) are defined by differing paradigms. Some languages are designed to support one paradigm (Smalltalk supports object-oriented programming, Haskell supports functional programming), while other programming languages support multiple paradigms (such as Object Pascal, C++, Java, JavaScript, C#, Scala, Visual Basic, Common Lisp, Scheme, Perl, PHP, Python, Ruby, Wolfram Language, Oz, and F#). For example, programs written in C++, Object Pascal or PHP can be purely procedural, purely object-oriented, or can contain elements of both or other paradigms. Software designers and programmers decide how to use those paradigm elements.\r\n\r\nIn object-oriented programming, programs are treated as a set of interacting objects. In functional programming, programs are treated as a sequence of stateless function evaluations. When programming computers or systems with many processors, in process-oriented programming, programs are treated as sets of concurrent processes that act on a logical shared data structures.\r\n\r\nMany programming paradigms are as well known for the techniques they forbid as for those they enable. For instance, pure functional programming disallows use of side-effects, while structured programming disallows use of the goto statement. Partly for this reason, new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles.[6] Yet, avoiding certain techniques can make it easier to understand program behavior, and to prove theorems about program correctness.\r\n\r\nProgramming paradigms can also be compared with programming models which allow invoking an execution model by using only an API. Programming models can also be classified into paradigms, based on features of the execution model.\r\n\r\nFor parallel computing, using a programming model instead of a language is common. The reason is that details of the parallel hardware leak into the abstractions used to program the hardware. This causes the programmer to have to map patterns in the algorithm onto patterns in the execution model (which have been inserted due to leakage of hardware into the abstraction). As a consequence, no one parallel programming language maps well to all computation problems. It is thus more convenient to use a base sequential language and insert API calls to parallel execution models, via a programming model. Such parallel programming models can be classified according to abstractions that reflect the hardware, such as shared memory, distributed memory with message passing, notions of place visible in the code, and so forth. These can be considered flavors of programming paradigm that apply to only parallel languages and programming models."}}, {"model": "wiki.page", "pk": 9, "fields": {"slug": "modeling-language", "created": "2019-11-06T01:47:12.540Z", "modified": "2019-11-06T01:47:12.540Z", "title": "Modeling Language", "author": 2, "content": "A modeling language can be graphical or textual.[1]\r\n\r\nGraphical modeling languages use a diagram technique with named symbols that represent concepts and lines that connect the symbols and represent relationships and various other graphical notation to represent constraints.\r\nTextual modeling languages may use standardized keywords accompanied by parameters or natural language terms and phrases to make computer-interpretable expressions.\r\nAn example of a graphical modeling language and a corresponding textual modeling language is EXPRESS.\r\n\r\nNot all modeling languages are executable, and for those that are, the use of them doesn't necessarily mean that programmers are no longer required. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more challenging problems, such as parallel computing and distributed systems.\r\n\r\nA large number of modeling languages appear in the literature."}}, {"model": "wiki.page", "pk": 10, "fields": {"slug": "unified-modeling-language-uml", "created": "2019-11-06T01:48:17.624Z", "modified": "2019-11-06T01:48:17.625Z", "title": "Unified Modeling Language (UML)", "author": 2, "content": "The Unified Modeling Language (UML) is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.[1]\r\n\r\nThe creation of UML was originally motivated by the desire to standardize the disparate notational systems and approaches to software design. It was developed by Grady Booch, Ivar Jacobson and James Rumbaugh at Rational Software in 1994\u20131995, with further development led by them through 1996.[1]\r\n\r\nIn 1997, UML was adopted as a standard by the Object Management Group (OMG), and has been managed by this organization ever since. In 2005, UML was also published by the International Organization for Standardization (ISO) as an approved ISO standard.[2] Since then the standard has been periodically revised to cover the latest revision of UML.[3]"}}, {"model": "wiki.page", "pk": 11, "fields": {"slug": "data-modeling", "created": "2019-11-06T01:48:55.206Z", "modified": "2019-11-06T01:48:55.207Z", "title": "Data Modeling", "author": 2, "content": "Data modeling is a process used to define and analyze data requirements needed to support the business processes within the scope of corresponding information systems in organizations. Therefore, the process of data modeling involves professional data modelers working closely with business stakeholders, as well as potential users of the information system.\r\n\r\nThere are three different types of data models produced while progressing from requirements to the actual database to be used for the information system.[2] The data requirements are initially recorded as a conceptual data model which is essentially a set of technology independent specifications about the data and is used to discuss initial requirements with the business stakeholders. The conceptual model is then translated into a logical data model, which documents structures of the data that can be implemented in databases. Implementation of one conceptual data model may require multiple logical data models. The last step in data modeling is transforming the logical data model to a physical data model that organizes the data into tables, and accounts for access, performance and storage details. Data modeling defines not just data elements, but also their structures and the relationships between them.[3]\r\n\r\nData modeling techniques and methodologies are used to model data in a standard, consistent, predictable manner in order to manage it as a resource. The use of data modeling standards is strongly recommended for all projects requiring a standard means of defining and analyzing data within an organization, e.g., using data modeling:\r\n\r\nto assist business analysts, programmers, testers, manual writers, IT package selectors, engineers, managers, related organizations and clients to understand and use an agreed semi-formal model the concepts of the organization and how they relate to one another\r\nto manage data as a resource\r\nfor the integration of information systems\r\nfor designing databases/data warehouses (aka data repositories)\r\nData modeling may be performed during various types of projects and in multiple phases of projects. Data models are progressive; there is no such thing as the final data model for a business or application. Instead a data model should be considered a living document that will change in response to a changing business. The data models should ideally be stored in a repository so that they can be retrieved, expanded, and edited over time. Whitten et al. (2004) determined two types of data modeling:[4]\r\n\r\nStrategic data modeling: This is part of the creation of an information systems strategy, which defines an overall vision and architecture for information systems. Information technology engineering is a methodology that embraces this approach.\r\nData modeling during systems analysis: In systems analysis logical data models are created as part of the development of new databases.\r\nData modeling is also used as a technique for detailing business requirements for specific databases. It is sometimes called database modeling because a data model is eventually implemented in a database.[4]"}}, {"model": "wiki.page", "pk": 12, "fields": {"slug": "systems-development-life-cycle-sdlc", "created": "2019-11-06T01:49:25.654Z", "modified": "2019-11-06T01:49:25.654Z", "title": "Systems Development Life Cycle (SDLC)", "author": 2, "content": "A systems development life cycle is composed of a number of clearly defined and distinct work phases which are used by systems engineers and systems developers to plan for, design, build, test, and deliver information systems. Like anything that is manufactured on an assembly line, an SDLC aims to produce high-quality systems that meet or exceed customer expectations, based on customer requirements, by delivering systems which move through each clearly defined phase, within scheduled time frames and cost estimates.[3] Computer systems are complex and often (especially with the recent rise of service-oriented architecture) link multiple traditional systems potentially supplied by different software vendors. To manage this level of complexity, a number of SDLC models or methodologies have been created, such as waterfall, spiral, Agile software development, rapid prototyping, incremental, and synchronize and stabilize.[4]\r\n\r\nSDLC can be described along a spectrum of agile to iterative to sequential methodologies. Agile methodologies, such as XP and Scrum, focus on lightweight processes which allow for rapid changes (without necessarily following the pattern of SDLC approach) along the development cycle. Iterative methodologies, such as Rational Unified Process and dynamic systems development method, focus on limited project scope and expanding or improving products by multiple iterations. Sequential or big-design-up-front (BDUF) models, such as waterfall, focus on complete and correct planning to guide large projects and risks to successful and predictable results.[citation needed] Other models, such as anamorphic development, tend to focus on a form of development that is guided by project scope and adaptive iterations of feature development.\r\n\r\nIn project management a project can be defined both with a project life cycle (PLC) and an SDLC, during which slightly different activities occur. According to Taylor (2004), \"the project life cycle encompasses all the activities of the project, while the systems development life cycle focuses on realizing the product requirements\".[5]\r\n\r\nSDLC is used during the development of an IT project, it describes the different stages involved in the project from the drawing board, through the completion of the project.\r\n\r\nThe SDLC is not a methodology per se, but rather a description of the phases in the life cycle of a software application. These phases (broadly speaking) are, investigation, analysis, design, build, test, implement, and maintenance and support. All software development methodologies (such as the more commonly known waterfall and scrum methodologies) follow the SDLC phases but the method of doing that varies vastly between methodologies. In the Scrum methodology, for example, one could say a single user story goes through all the phases of the SDLC within a single two-week sprint. Contrast this to the waterfall methodology, as another example, where every business requirement (recorded in the analysis phase of the SDLC in a document called the Business Requirements Specification) is translated into feature/functional descriptions (recorded in the design phase in a document called the Functional Specification) which are then all built in one go as a collection of solution features typically over a period of three to nine months, or more. These methodologies are obviously quite different approaches, yet they both contain the SDLC phases in which a requirement is born, then travels through the life cycle phases ending in the final phase of maintenance and support, after-which (typically) the whole life cycle starts again for a subsequent version of the software application."}}, {"model": "wiki.page", "pk": 13, "fields": {"slug": "spiral-development-model", "created": "2019-11-06T01:49:48.969Z", "modified": "2019-11-06T01:49:48.969Z", "title": "Spiral Development Model", "author": 2, "content": "In 1988, Barry Boehm published a formal software system development \"spiral model,\" which combines some key aspect of the waterfall model and rapid prototyping methodologies, in an effort to combine advantages of top-down and bottom-up concepts. It provided emphasis in a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems.\r\n\r\nThe basic principles are:[1]\r\n\r\nFocus is on risk assessment and on minimizing project risk by breaking a project into smaller segments and providing more ease-of-change during the development process, as well as providing the opportunity to evaluate risks and weigh consideration of project continuation throughout the life cycle.\r\n\"Each cycle involves a progression through the same sequence of steps, for each part of the product and for each of its levels of elaboration, from an overall concept-of-operation document down to the coding of each individual program.\"[10]\r\nEach trip around the spiral traverses four basic quadrants: (1) determine objectives, alternatives, and constraints of the iteration; (2) evaluate alternatives; Identify and resolve risks; (3) develop and verify deliverables from the iteration; and (4) plan the next iteration.[11]\r\nBegin each cycle with an identification of stakeholders and their \"win conditions\", and end each cycle with review and commitment.[12]"}}, {"model": "wiki.page", "pk": 14, "fields": {"slug": "design-driven-development", "created": "2019-11-06T01:50:20.009Z", "modified": "2019-11-06T01:50:20.009Z", "title": "Design Driven Development", "author": 2, "content": "Design-Driven Development is an agile-based process for creating innovative requirements to build better solutions. It works closely with SCRUM and Extreme Programming (XP) for managing and implementing those requirements. Also it can work with non-agile processes such as RUP.\r\n\r\nIt is based on the following philosophy:\r\n\r\nDesign is an art of creating beautiful, elegant, and innovative solutions, which works in the user and customer context.\r\nNo process can guarantee a better design; creating the right environment and set of people is the only way to bring innovation.\r\nDesign is an accident that kicks in at conception, and Design-Driven Development creates maximum opportunities to make accidents happen."}}, {"model": "wiki.page", "pk": 15, "fields": {"slug": "waterfall-method-of-software-development", "created": "2019-11-06T01:51:00.792Z", "modified": "2019-11-06T01:51:00.792Z", "title": "Waterfall Method of Software Development", "author": 2, "content": "The first known presentation describing use of such phases in software engineering was held by Herbert D. Benington at the Symposium on Advanced Programming Methods for Digital Computers on 29 June 1956.[2] This presentation was about the development of software for SAGE. In 1983 the paper was republished with a foreword by Benington explaining that the phases were on purpose organised according to the specialisation of tasks, and pointing out that the process was not in fact performed in a strict top-down fashion, but depended on a prototype.[1]\r\n\r\nThe first formal description of the waterfall model is often cited as a 1970 article by Winston W. Royce,[3][4] although Royce did not use the term waterfall in that article. Royce presented this model as an example of a flawed, non-working model; which is how the term is generally used in writing about software development\u2014to describe a critical view of a commonly used software development practice.[5]\r\n\r\nThe earliest use of the term \"waterfall\" may have been in a 1976 paper by Bell and Thayer.[6]\r\n\r\nIn 1985, the United States Department of Defense captured this approach in DOD-STD-2167A, their standards for working with software development contractors, which stated that \"the contractor shall implement a software development cycle that includes the following six phases: Preliminary Design, Detailed Design, Coding and Unit Testing, Integration, and Testing\".[7]"}}, {"model": "wiki.page", "pk": 16, "fields": {"slug": "software-design", "created": "2019-11-06T01:51:18.426Z", "modified": "2019-11-06T01:51:18.426Z", "title": "Software Design", "author": 2, "content": "Software design is the process of envisioning and defining software solutions to one or more sets of problems. One of the main components of software design is the software requirements analysis (SRA). SRA is a part of the software development process that lists specifications used in software engineering. If the software is \"semi-automated\" or user centered, software design may involve user experience design yielding a storyboard to help determine those specifications. If the software is completely automated (meaning no user or user interface), a software design may be as simple as a flow chart or text describing a planned sequence of events. There are also semi-standard methods like Unified Modeling Language and Fundamental modeling concepts. In either case, some documentation of the plan is usually the product of the design. Furthermore, a software design may be platform-independent or platform-specific, depending upon the availability of the technology used for the design.\r\n\r\nThe main difference between software analysis and design is that the output of a software analysis consists of smaller problems to solve. Additionally, the analysis should not be designed very differently across different team members or groups. In contrast, the design focuses on capabilities, and thus multiple designs for the same problem can and will exist. Depending on the environment, the design often varies, whether it is created from reliable frameworks or implemented with suitable design patterns. Design examples include operation systems, webpages, mobile devices or even the new cloud computing paradigm.\r\n\r\nSoftware design is both a process and a model. The design process is a sequence of steps that enables the designer to describe all aspects of the software for building. Creative skill, past experience, a sense of what makes \"good\" software, and an overall commitment to quality are examples of critical success factors for a competent design. It is important to note, however, that the design process is not always a straightforward procedure; the design model can be compared to an architect's plans for a house. It begins by representing the totality of the thing that is to be built (e.g., a three-dimensional rendering of the house); slowly, the thing is refined to provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the design model that is created for software provides a variety of different views of the computer software. Basic design principles enable the software engineer to navigate the design process. Davis[3] suggests a set of principles for software design, which have been adapted and extended in the following list:\r\n\r\nThe design process should not suffer from \"tunnel vision.\" A good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job.\r\nThe design should be traceable to the analysis model. Because a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model.\r\nThe design should not reinvent the wheel. Systems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable).\r\nThe design should \"minimize the intellectual distance\" between the software and the problem as it exists in the real world. That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain.\r\nThe design should exhibit uniformity and integration. A design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components.\r\nThe design should be structured to accommodate change. The design concepts discussed in the next section enable a design to achieve this principle.\r\nThe design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered. Well-designed software should never \"bomb\"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner.\r\nDesign is not coding, coding is not design. Even when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded.\r\nThe design should be assessed for quality as it is being created, not after the fact. A variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process.\r\nThe design should be reviewed to minimize conceptual (semantic) errors. There is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model."}}, {"model": "wiki.page", "pk": 17, "fields": {"slug": "user-interface-design", "created": "2019-11-06T01:51:46.360Z", "modified": "2019-11-06T01:51:46.360Z", "title": "User Interface Design", "author": 2, "content": "User interface design (UI) or user interface engineering is the design of user interfaces for machines and software, such as computers, home appliances, mobile devices, and other electronic devices, with the focus on maximizing usability and the user experience. The goal of user interface design is to make the user's interaction as simple and efficient as possible, in terms of accomplishing user goals (user-centered design).\r\n\r\nGood user interface design facilitates finishing the task at hand without drawing unnecessary attention to itself. Graphic design and typography are utilized to support its usability, influencing how the user performs certain interactions and improving the aesthetic appeal of the design; design aesthetics may enhance or detract from the ability of users to use the functions of the interface.[1] The design process must balance technical functionality and visual elements (e.g., mental model) to create a system that is not only operational but also usable and adaptable to changing user needs.\r\n\r\nInterface design is involved in a wide range of projects from computer systems, to cars, to commercial planes; all of these projects involve much of the same basic human interactions yet also require some unique skills and knowledge. As a result, designers tend to specialize in certain types of projects and have skills centered on their expertise, whether it is a software design, user research, web design, or industrial design."}}, {"model": "wiki.page", "pk": 18, "fields": {"slug": "lion", "created": "2019-11-18T22:47:43.712Z", "modified": "2019-12-29T10:39:06.614Z", "title": "Lion", "author": 1, "content": "the lion roars loudly\r\n\r\n\r\nthis has been edited\r\njhgjhbk"}}, {"model": "admin.logentry", "pk": 1, "fields": {"action_time": "2019-11-04T21:16:48.769Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Page object (1)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 2, "fields": {"action_time": "2019-11-04T22:24:18.582Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "Section A BEW", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 3, "fields": {"action_time": "2019-11-05T22:34:33.903Z", "user": 1, "content_type": 4, "object_id": "2", "object_repr": "dani", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 4, "fields": {"action_time": "2019-11-05T22:35:44.622Z", "user": 1, "content_type": 4, "object_id": "2", "object_repr": "dani", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"first_name\", \"last_name\", \"email\", \"is_staff\", \"is_superuser\"]}}]"}}, {"model": "admin.logentry", "pk": 5, "fields": {"action_time": "2019-11-05T22:38:05.036Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "section b bew 1.2", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 6, "fields": {"action_time": "2019-11-06T01:43:08.401Z", "user": 1, "content_type": 7, "object_id": "4", "object_repr": "Computer Science", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 7, "fields": {"action_time": "2019-11-06T01:44:13.606Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "section b bew 1.2", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 8, "fields": {"action_time": "2019-11-06T01:44:13.607Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "Section A BEW", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 9, "fields": {"action_time": "2019-11-06T01:44:13.608Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Test", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 10, "fields": {"action_time": "2019-11-06T01:45:31.621Z", "user": 1, "content_type": 7, "object_id": "5", "object_repr": "Software Engineering History", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 11, "fields": {"action_time": "2019-11-06T01:46:09.034Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Software Testing", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 12, "fields": {"action_time": "2019-11-06T01:46:30.186Z", "user": 1, "content_type": 7, "object_id": "7", "object_repr": "Systems Engineering", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 13, "fields": {"action_time": "2019-11-06T01:46:54.579Z", "user": 1, "content_type": 7, "object_id": "8", "object_repr": "Programming Paradigms", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 14, "fields": {"action_time": "2019-11-06T01:47:12.540Z", "user": 1, "content_type": 7, "object_id": "9", "object_repr": "Modeling Language", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 15, "fields": {"action_time": "2019-11-06T01:48:17.625Z", "user": 1, "content_type": 7, "object_id": "10", "object_repr": "Unified Modeling Language (UML)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 16, "fields": {"action_time": "2019-11-06T01:48:55.207Z", "user": 1, "content_type": 7, "object_id": "11", "object_repr": "Data Modeling", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 17, "fields": {"action_time": "2019-11-06T01:49:25.654Z", "user": 1, "content_type": 7, "object_id": "12", "object_repr": "Systems Development Life Cycle (SDLC)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 18, "fields": {"action_time": "2019-11-06T01:49:48.970Z", "user": 1, "content_type": 7, "object_id": "13", "object_repr": "Spiral Development Model", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 19, "fields": {"action_time": "2019-11-06T01:50:20.010Z", "user": 1, "content_type": 7, "object_id": "14", "object_repr": "Design Driven Development", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 20, "fields": {"action_time": "2019-11-06T01:51:00.793Z", "user": 1, "content_type": 7, "object_id": "15", "object_repr": "Waterfall Method of Software Development", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 21, "fields": {"action_time": "2019-11-06T01:51:18.427Z", "user": 1, "content_type": 7, "object_id": "16", "object_repr": "Software Design", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 22, "fields": {"action_time": "2019-11-06T01:51:46.361Z", "user": 1, "content_type": 7, "object_id": "17", "object_repr": "User Interface Design", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}]